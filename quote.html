<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cute Quote Card Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;600&family=Comfortaa:wght@500;600&family=Grandstander:wght@500;600&family=Inter:wght@500;600&family=Lora:wght@500;600&family=Merienda:wght@500;700&family=Merriweather:wght@500;700&family=Nunito:wght@500;600&family=Quicksand:wght@500;600&family=Signika:wght@500;600&display=swap&subset=vietnamese"
    rel="stylesheet"
  />
  <style>
    :root {
      color-scheme: light;
      font-family: "Be Vietnam Pro", "Nunito", "Inter", system-ui;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #fdf2ff, #fff4e5);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .app-shell {
      width: min(1200px, 100%);
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      align-items: start;
    }

    .control-panel {
      background: rgba(255, 255, 255, 0.9);
      padding: 24px;
      border-radius: 20px;
      box-shadow: 0 18px 38px rgba(255, 163, 234, 0.25);
      display: flex;
      flex-direction: column;
      gap: 16px;
      border: 2px solid rgba(255, 200, 229, 0.6);
    }

    .control-panel h1 {
      margin: 0 0 8px;
      font-size: 1.6rem;
      color: #8b3a71;
      font-weight: 700;
    }

    label {
      font-weight: 600;
      color: #70445f;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 0.95rem;
    }

    textarea {
      resize: vertical;
      min-height: 104px;
      border-radius: 16px;
      padding: 16px;
      border: 1px solid rgba(230, 185, 205, 0.7);
      font-size: 1rem;
      font-family: inherit;
      background: #fff9ff;
    }

    select,
    input[type="range"] {
      width: 100%;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(226, 180, 210, 0.6);
      background: #fffafc;
      font-size: 1rem;
      font-family: inherit;
    }

    .range-display {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #8f5473;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    button {
      flex: 1;
      min-width: 150px;
      padding: 12px 16px;
      border-radius: 16px;
      border: none;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button.render {
      background: linear-gradient(135deg, #ffd1ec, #ffe4f8);
      color: #8b2f68;
      box-shadow: 0 12px 24px rgba(255, 128, 188, 0.3);
    }

    button.download {
      background: linear-gradient(135deg, #c8f6ff, #e8fffa);
      color: #256d74;
      box-shadow: 0 12px 24px rgba(120, 213, 214, 0.3);
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 28px rgba(0, 0, 0, 0.12);
    }

    .canvas-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
      border-radius: 24px;
      background: rgba(255, 255, 255, 0.7);
      box-shadow: inset 0 0 0 2px rgba(255, 200, 229, 0.4);
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 28px;
      border: 8px solid rgba(255, 195, 228, 0.6);
      box-shadow: 0 30px 60px rgba(233, 170, 220, 0.35);
      background: white;
    }

    @media (max-width: 720px) {
      body {
        padding: 16px;
      }

      .control-panel {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <section class="control-panel">
      <h1>üéÄ Cute Quote Card Generator</h1>
      <label>
        Nh·∫≠p c√¢u quote th·∫≠t hay nh√© üíï
        <textarea id="quoteInput" placeholder="H√£y vi·∫øt ƒëi·ªÅu khi·∫øn b·∫°n m·ªâm c∆∞·ªùi..."></textarea>
      </label>

      <label>
        Ch·ªçn font ch·ªØ:
        <select id="fontSelect">
          <option value='"Be Vietnam Pro", sans-serif' data-font="Be Vietnam Pro">Be Vietnam Pro</option>
          <option value='"Nunito", sans-serif' data-font="Nunito">Nunito</option>
          <option value='"Quicksand", sans-serif' data-font="Quicksand">Quicksand</option>
          <option value='"Inter", sans-serif' data-font="Inter">Inter</option>
          <option value='"Comfortaa", sans-serif' data-font="Comfortaa">Comfortaa</option>
          <option value='"Grandstander", cursive' data-font="Grandstander">Grandstander</option>
          <option value='"Merienda", cursive' data-font="Merienda">Merienda</option>
          <option value='"Merriweather", serif' data-font="Merriweather">Merriweather</option>
          <option value='"Lora", serif' data-font="Lora">Lora</option>
          <option value='"Signika", sans-serif' data-font="Signika">Signika</option>
        </select>
      </label>

      <label>
        K√≠ch th∆∞·ªõc ch·ªØ:
        <div class="range-display">
          <span>Nh·ªè</span>
          <span id="fontSizeLabel">52px</span>
        </div>
        <input type="range" id="fontSizeRange" min="32" max="96" step="2" value="52" />
      </label>

      <label>
        Kho·∫£ng c√°ch d√≤ng:
        <div class="range-display">
          <span>S√°t</span>
          <span id="lineSpacingLabel">1.30</span>
        </div>
        <input type="range" id="lineSpacingRange" min="1" max="2" step="0.05" value="1.3" />
      </label>

      <label>
        B·∫£ng m√†u pastel:
        <select id="paletteSelect">
          <option value="pastelPink">Pastel H·ªìng</option>
          <option value="pastelPurple">Pastel T√≠m</option>
          <option value="pastelMint">Pastel Xanh Mint</option>
          <option value="pastelPeach">Pastel Cam Kem</option>
        </select>
      </label>

      <label>
        K√≠ch th∆∞·ªõc ·∫£nh:
        <select id="sizeSelect">
          <option value="square1080">Facebook Feed Square 1080 x 1080</option>
          <option value="story1080">Facebook Story / Reels / TikTok 1080 x 1920</option>
          <option value="landscape1920">Landscape Social 1920 x 1080</option>
        </select>
      </label>

      <div class="button-group">
        <button class="render" id="renderBtn">Render / Preview</button>
        <button class="download" id="downloadBtn">Download PNG</button>
      </div>
    </section>

    <section class="canvas-wrapper">
      <canvas id="quoteCanvas" width="1080" height="1080"></canvas>
    </section>
  </div>

  <script>
    // Palette definitions with harmonious pastel colors.
    const palettes = {
      pastelPink: {
        gradientStart: "#fff6fb",
        gradientEnd: "#fffbe8",
        paperFill: "rgba(255, 255, 255, 0.92)",
        paperBorder: "#ffd4ec",
        lineColor: "rgba(255, 170, 220, 0.35)",
        textColor: "#4a2141",
        heartColor: "#ff7bb6",
        starColor: "#ffcf4d",
        sparkleColor: "#9acbff",
      },
      pastelPurple: {
        gradientStart: "#f3ecff",
        gradientEnd: "#e5fff8",
        paperFill: "rgba(255, 255, 255, 0.94)",
        paperBorder: "#d7c9ff",
        lineColor: "rgba(200, 180, 255, 0.35)",
        textColor: "#402a5f",
        heartColor: "#a07bff",
        starColor: "#ffe066",
        sparkleColor: "#c0f4ff",
      },
      pastelMint: {
        gradientStart: "#ecfffb",
        gradientEnd: "#fff4fc",
        paperFill: "rgba(255, 255, 255, 0.94)",
        paperBorder: "#baf4e6",
        lineColor: "rgba(168, 234, 210, 0.4)",
        textColor: "#2f4e4a",
        heartColor: "#ff94c2",
        starColor: "#ffd86f",
        sparkleColor: "#9bd8ff",
      },
      pastelPeach: {
        gradientStart: "#fff3ea",
        gradientEnd: "#fffbe9",
        paperFill: "rgba(255, 255, 255, 0.93)",
        paperBorder: "#ffd4b8",
        lineColor: "rgba(255, 199, 153, 0.38)",
        textColor: "#5e3a2e",
        heartColor: "#ff8ba7",
        starColor: "#ffe08b",
        sparkleColor: "#ffcdde",
      },
    };

    // Output sizes available for quick selection.
    const canvasSizes = {
      square1080: { width: 1080, height: 1080 },
      story1080: { width: 1080, height: 1920 },
      landscape1920: { width: 1920, height: 1080 },
    };

    // UI references.
    const quoteInput = document.getElementById("quoteInput");
    const fontSelect = document.getElementById("fontSelect");
    const fontSizeRange = document.getElementById("fontSizeRange");
    const fontSizeLabel = document.getElementById("fontSizeLabel");
    const paletteSelect = document.getElementById("paletteSelect");
    const sizeSelect = document.getElementById("sizeSelect");
    const renderBtn = document.getElementById("renderBtn");
    const downloadBtn = document.getElementById("downloadBtn");
    const canvas = document.getElementById("quoteCanvas");
    const ctx = canvas.getContext("2d");
    const lineSpacingRange = document.getElementById("lineSpacingRange");
    const lineSpacingLabel = document.getElementById("lineSpacingLabel");

    // Default quote to inspire the user on first render.
    quoteInput.value = "H√£y y√™u nh·ªØng ƒëi·ªÅu nh·ªè xinh khi·∫øn tr√°i tim b·∫°n n·ªü hoa üíñ";

    // Update slider label when the font size changes.
    const updateFontSizeLabel = () => {
      fontSizeLabel.textContent = `${fontSizeRange.value}px`;
    };

    updateFontSizeLabel();

    fontSizeRange.addEventListener("input", () => {
      updateFontSizeLabel();
      renderAll();
    });

    const updateLineSpacingLabel = () => {
      lineSpacingLabel.textContent = Number(lineSpacingRange.value).toFixed(2);
    };

    updateLineSpacingLabel();

    lineSpacingRange.addEventListener("input", () => {
      updateLineSpacingLabel();
      renderAll();
    });

    const fontLoadCache = new Map();

    function getPrimaryFontName(optionEl) {
      if (!optionEl) return "";
      if (optionEl.dataset.font) return optionEl.dataset.font;
      return optionEl.value.split(",")[0].replace(/['"]/g, "").trim();
    }

    function ensureFontLoaded(fontName) {
      if (!fontName || !document.fonts) return Promise.resolve();
      if (!fontLoadCache.has(fontName)) {
        const loadPromise = document.fonts
          .load(`48px "${fontName}"`)
          .catch(() => undefined);
        fontLoadCache.set(fontName, loadPromise);
      }
      return fontLoadCache.get(fontName);
    }

    fontSelect.addEventListener("change", async () => {
      const optionEl = fontSelect.selectedOptions[0];
      await ensureFontLoaded(getPrimaryFontName(optionEl));
      renderAll();
    });
    paletteSelect.addEventListener("change", renderAll);
    quoteInput.addEventListener("input", renderAll);

    sizeSelect.addEventListener("change", () => {
      const { width, height } = canvasSizes[sizeSelect.value];
      canvas.width = width;
      canvas.height = height;
      renderAll();
    });

    renderBtn.addEventListener("click", async () => {
      await ensureFontLoaded(getPrimaryFontName(fontSelect.selectedOptions[0]));
      renderAll();
    });

    downloadBtn.addEventListener("click", () => {
      // Trigger a download of the current canvas content as PNG.
      const link = document.createElement("a");
      link.download = "quote.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

    /**
     * Draw the dreamy gradient background.
     */
    function drawBackground(palette) {
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, palette.gradientStart);
      gradient.addColorStop(1, palette.gradientEnd);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    /**
     * Draw the rounded paper sheet placed inside the canvas.
     */
    function drawPaper(palette, metrics) {
      const { x, y, width, height, radius } = metrics;
      ctx.save();
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(x, y, width, height, radius);
      } else {
        // Manual rounded rectangle path for wider browser support.
        const r = radius;
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
      }
      ctx.fillStyle = palette.paperFill;
      ctx.fill();
      ctx.lineWidth = Math.max(4, canvas.width * 0.004);
      ctx.strokeStyle = palette.paperBorder;
      ctx.stroke();
      ctx.shadowColor = "rgba(200, 170, 200, 0.35)";
      ctx.shadowBlur = 20;
      ctx.shadowOffsetY = 12;
      ctx.fill();
      ctx.restore();
    }

    /**
     * Draw equally spaced notebook-style lines across the paper.
     */
    function drawLines(palette, metrics, lineHeight) {
      const { x, y, width, height, padding } = metrics;
      const firstLineY = y + padding;
      const lastLineY = y + height - padding;

      ctx.save();
      ctx.strokeStyle = palette.lineColor;
      ctx.lineWidth = Math.max(1, canvas.width * 0.002);
      ctx.beginPath();

      for (let lineY = firstLineY; lineY <= lastLineY; lineY += lineHeight) {
        ctx.moveTo(x + padding * 0.5, lineY);
        ctx.lineTo(x + width - padding * 0.5, lineY);
      }

      ctx.stroke();
      ctx.restore();
    }

    /**
     * Draw adorable doodles (heart, star, sparkle) to decorate the paper.
     */
    function drawDoodles(palette, metrics) {
      const { x, y, width, height, padding } = metrics;

      ctx.save();
      ctx.translate(0, 0);

      // Heart doodle (top-left)
      const heartX = x + padding * 0.5;
      const heartY = y + padding * 0.7;
      const heartSize = Math.min(width, height) * 0.06;
      ctx.fillStyle = palette.heartColor;
      ctx.beginPath();
      ctx.moveTo(heartX, heartY + heartSize / 4);
      ctx.bezierCurveTo(
        heartX - heartSize / 2,
        heartY - heartSize / 2,
        heartX - heartSize,
        heartY + heartSize / 3,
        heartX,
        heartY + heartSize
      );
      ctx.bezierCurveTo(
        heartX + heartSize,
        heartY + heartSize / 3,
        heartX + heartSize / 2,
        heartY - heartSize / 2,
        heartX,
        heartY + heartSize / 4
      );
      ctx.fill();

      // Star doodle (top-right)
      const starX = x + width - padding * 0.6;
      const starY = y + padding * 0.6;
      const starOuter = Math.min(width, height) * 0.05;
      const starInner = starOuter * 0.45;
      ctx.fillStyle = palette.starColor;
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const outerAngle = ((Math.PI * 2) / 5) * i - Math.PI / 2;
        const innerAngle = outerAngle + Math.PI / 5;
        ctx.lineTo(starX + Math.cos(outerAngle) * starOuter, starY + Math.sin(outerAngle) * starOuter);
        ctx.lineTo(starX + Math.cos(innerAngle) * starInner, starY + Math.sin(innerAngle) * starInner);
      }
      ctx.closePath();
      ctx.fill();

      // Sparkle doodle (bottom-right)
      const sparkleX = x + width - padding;
      const sparkleY = y + height - padding * 0.8;
      const sparkleSize = Math.min(width, height) * 0.045;
      ctx.fillStyle = palette.sparkleColor;
      ctx.beginPath();
      ctx.moveTo(sparkleX, sparkleY - sparkleSize);
      ctx.quadraticCurveTo(sparkleX + sparkleSize * 0.3, sparkleY - sparkleSize * 0.3, sparkleX + sparkleSize, sparkleY);
      ctx.quadraticCurveTo(sparkleX + sparkleSize * 0.3, sparkleY + sparkleSize * 0.3, sparkleX, sparkleY + sparkleSize);
      ctx.quadraticCurveTo(sparkleX - sparkleSize * 0.3, sparkleY + sparkleSize * 0.3, sparkleX - sparkleSize, sparkleY);
      ctx.quadraticCurveTo(sparkleX - sparkleSize * 0.3, sparkleY - sparkleSize * 0.3, sparkleX, sparkleY - sparkleSize);
      ctx.fill();

      // Tiny hearts bottom-left for balance
      const tinyHeartX = x + padding * 0.7;
      const tinyHeartY = y + height - padding * 0.8;
      const tinySize = heartSize * 0.5;
      ctx.fillStyle = palette.heartColor;
      ctx.beginPath();
      ctx.moveTo(tinyHeartX, tinyHeartY + tinySize / 4);
      ctx.bezierCurveTo(
        tinyHeartX - tinySize / 2,
        tinyHeartY - tinySize / 2,
        tinyHeartX - tinySize,
        tinyHeartY + tinySize / 3,
        tinyHeartX,
        tinyHeartY + tinySize
      );
      ctx.bezierCurveTo(
        tinyHeartX + tinySize,
        tinyHeartY + tinySize / 3,
        tinyHeartX + tinySize / 2,
        tinyHeartY - tinySize / 2,
        tinyHeartX,
        tinyHeartY + tinySize / 4
      );
      ctx.fill();

      ctx.restore();
    }

    /**
     * Break the user's quote into lines that fit the available width,
     * respecting manual line breaks from the textarea.
     */
    function wrapText(text, maxWidth, fontSize, fontFamily) {
      ctx.save();
      ctx.font = `${fontSize}px ${fontFamily}`;
      const paragraphs = text.replace(/\r/g, "").split("\n");
      const lines = [];

      paragraphs.forEach((paragraph) => {
        const trimmed = paragraph.trim();
        if (!trimmed) {
          // Preserve intentional blank lines.
          lines.push("");
          return;
        }

        const words = trimmed.split(/\s+/);
        let currentLine = words[0];

        for (let i = 1; i < words.length; i++) {
          const word = words[i];
          const tentative = `${currentLine} ${word}`;
          if (ctx.measureText(tentative).width > maxWidth) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = tentative;
          }
        }

        lines.push(currentLine);
      });

      ctx.restore();
      return lines;
    }

    /**
     * Draw the wrapped quote text aligned with the notebook lines.
     */
    function drawQuoteText(palette, metrics, lines, fontSize, fontFamily, lineHeight) {
      const { x, y, width, padding } = metrics;
      const textAreaWidth = width - padding * 2;
      const startY = y + padding + lineHeight / 2;

      ctx.save();
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.fillStyle = palette.textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const centerX = x + width / 2;

      lines.forEach((line, index) => {
        const lineY = startY + index * lineHeight;
        ctx.fillText(line, centerX, lineY);
      });

      ctx.restore();
    }

    /**
     * Master render function orchestrating all drawing steps.
     */
    function renderAll() {
      const palette = palettes[paletteSelect.value];
      const fontFamily = fontSelect.value;
      const fontSize = parseInt(fontSizeRange.value, 10);
      const lineHeight = fontSize * Number(lineSpacingRange.value);

      // Paper metrics scale with canvas size for proportional layout.
      const paperMargin = canvas.width * 0.075;
      const paperWidth = canvas.width - paperMargin * 2;
      const paperHeight = canvas.height - paperMargin * 2;
      const paperMetrics = {
        x: paperMargin,
        y: paperMargin,
        width: paperWidth,
        height: paperHeight,
        radius: Math.min(canvas.width, canvas.height) * 0.06,
        padding: Math.min(canvas.width, canvas.height) * 0.075,
      };

      const maxTextWidth = paperMetrics.width - paperMetrics.padding * 2;
      const rawQuote = quoteInput.value;
      const quoteText = rawQuote.trim().length ? rawQuote : "B·∫°n th·∫≠t d·ªÖ th∆∞∆°ng khi m·ªâm c∆∞·ªùi ‚ú®";
      const lines = wrapText(quoteText, maxTextWidth, fontSize, fontFamily);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBackground(palette);
      drawPaper(palette, paperMetrics);
      drawLines(palette, paperMetrics, lineHeight);
      drawDoodles(palette, paperMetrics);
      drawQuoteText(palette, paperMetrics, lines, fontSize, fontFamily, lineHeight);
    }

    // Render initial state to show preview immediately.
    ensureFontLoaded(getPrimaryFontName(fontSelect.selectedOptions[0])).then(renderAll);
  </script>
</body>
</html>
